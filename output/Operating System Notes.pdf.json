[{"type":"Title","element_id":"bcb4d3eafc8c4ff32ed17d34b9cbca97","text":"Operating Systems","metadata":{"coordinates":{"points":[[673.9352416992188,211.06900024414062],[673.9352416992188,267.6905517578125],[1025.0272216796875,267.6905517578125],[1025.0272216796875,211.06900024414062]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"aa3f8857a4565cae68b033d005d97b4f","text":"● An Operating System can be defined as an interface between user and hardware. It is responsible for the execution of all the processes, Resource Allocation, CPU management, File Management and many other tasks. The purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.","metadata":{"coordinates":{"points":[[250,358.37579345703125],[250,558.1041259765625],[1506.44287109375,558.1041259765625],[1506.44287109375,358.37579345703125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"bcb4d3eafc8c4ff32ed17d34b9cbca97","filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"e2df610fc6933b0797b3a99e9bd2b40f","text":"● Types of Operating Systems :","metadata":{"coordinates":{"points":[[250,679.612548828125],[250,728.3507080078125],[758.440185546875,728.3507080078125],[758.440185546875,679.612548828125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"37074b7c058f5f9d436336f024bc8474","text":"1. Batch OS – A set of similar jobs are stored in the main memory for execution. A job gets assigned to the CPU, only when the execution of the previous job completes.","metadata":{"coordinates":{"points":[[250,769.1610717773438],[250,862.866943359375],[1491.3505647916666,862.866943359375],[1491.3505647916666,769.1610717773438]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"59cd2805fedd12acb818a47f7dc987a1","text":"2. Multiprogramming OS – The main memory consists of jobs waiting for CPU time. The OS selects one of the processes and assigns it to the CPU. Whenever the executing process needs to wait for any other operation (like I/O), the OS selects another process from the job queue and assigns it to the CPU. This way, the CPU is never kept idle and the user gets the flavor of getting multiple tasks done at once.","metadata":{"coordinates":{"points":[[250,881.4920654296875],[250,1140.4041748046875],[1481.3067626953125,1140.4041748046875],[1481.3067626953125,881.4920654296875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"2ef00e9a5b6476256e549d6593b8bc23","text":"3. Multitasking OS – Multitasking OS combines the benefits of Multiprogramming OS and CPU scheduling to perform quick switches between jobs. The switch is so quick that the user can interact with each program as it runs.","metadata":{"coordinates":{"points":[[250,1158.132080078125],[250,1307.73193359375],[1456.3011474609375,1307.73193359375],[1456.3011474609375,1158.132080078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"c4924feb1c5a9f0a10bd644a5a221b20","text":"4. Time Sharing OS – Time-sharing systems require interaction with the user to instruct the OS to perform various tasks. The OS responds with an output. The instructions are usually given through an input device like the keyboard.","metadata":{"coordinates":{"points":[[250,1324.5225830078125],[250,1473.5023193359375],[1480.462890625,1473.5023193359375],[1480.462890625,1324.5225830078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"92386c850794699fbd1aeb43a864423b","text":"5. Real Time OS – Real-Time OS are usually built for dedicated systems to accomplish a specific set of tasks within deadlines.","metadata":{"coordinates":{"points":[[244.57589721679688,1490.289794921875],[244.57589721679688,1585.0919189453125],[1484.6602783203125,1585.0919189453125],[1484.6602783203125,1490.289794921875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"511dd9f60eaffb27f242d2ba85e59160","text":"● Process : A process is a program under execution. The value of the program counter (PC) indicates the address of the next instruction of the process being executed. Each process is represented by a Process Control Block (PCB).","metadata":{"coordinates":{"points":[[250,1655.073974609375],[250,1808.4478759765625],[1493.27001953125,1808.4478759765625],[1493.27001953125,1655.073974609375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"parent_id":"e2df610fc6933b0797b3a99e9bd2b40f","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"edf8fbce73a734dc15890c2656616d33","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.3023681640625,2058.02783203125],[197.3023681640625,2096.42919921875],[404.89093017578125,2096.42919921875],[404.89093017578125,2058.02783203125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"filename":"Operating System Notes.pdf"}},{"type":"UncategorizedText","element_id":"f7f2a0e69d90177e6a60b1cfd15b669b","text":"1","metadata":{"coordinates":{"points":[[1455.5664166666666,2060.917161375],[1455.5664166666666,2094.250494708333],[1474.104828,2094.250494708333],[1474.104828,2060.917161375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":1,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"544aa06c8372ba074f966f3c47b54efb","text":"● Process Scheduling:","metadata":{"coordinates":{"points":[[250,257.59210205078125],[250,293.8131103515625],[605.239990234375,293.8131103515625],[605.239990234375,257.59210205078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"659f26dfed18eb7815af75ecf85b826a","text":"1. Arrival Time – Time at which the process arrives in the ready queue.","metadata":{"coordinates":{"points":[[300,316.442698780436],[300,352.55381128043615],[1283.4491578457162,352.55381128043615],[1283.4491578457162,316.442698780436]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"b6a1aa68d8253177dd87c149102c4e83","text":"2. Completion Time – Time at which process completes its execution.","metadata":{"coordinates":{"points":[[300,382.05091544710274],[300,418.46478271484375],[1268.0182282623832,418.46478271484375],[1268.0182282623832,382.05091544710274]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"4419b59660d72937743d80c4a83cc845","text":"3. Burst Time – Time required by a process for CPU execution.","metadata":{"coordinates":{"points":[[300,447.6591293359917],[300,485.5687561035156],[1176.446618262383,485.5687561035156],[1176.446618262383,447.6591293359917]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","text":"E","metadata":{"coordinates":{"points":[[300,384],[300,541],[318,541],[318,384]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7126fe6f2234dae85284864092f3cce9","text":"4. Turn Around Time – Time Difference between completion time and arrival time. Turn Around Time = Completion Time - Arrival Time","metadata":{"coordinates":{"points":[[300,513.2676932248804],[300,609.5872192382812],[1441.8485107421875,609.5872192382812],[1441.8485107421875,513.2676932248804]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"ba66d858f90388686837610dcd70619c","text":"5. Waiting Time (WT) – Time Difference between turn around time and burst time. Waiting Time = Turnaround Time - Burst Time","metadata":{"coordinates":{"points":[[282.5018005371094,634.3809204101562],[282.5018005371094,730.9439697265625],[1444.796630859375,730.9439697265625],[1444.796630859375,634.3809204101562]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"a07409bc0da79e790fbfc930d2cdcb92","text":"● Thread (Important) : A thread is a lightweight process and forms the basic unit of CPU utilization. A process can perform more than one task at the same time by including multiple threads.","metadata":{"coordinates":{"points":[[250,811.0283598915472],[250,966.14501953125],[1503.170654296875,966.14501953125],[1503.170654296875,811.0283598915472]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"1cb6c2de0106915d649a371ba4a8e4d0","text":"● A thread has its own program counter, register set, and stack","metadata":{"coordinates":{"points":[[300,987.666137669325],[300,1026.6539306640625],[1177.4814453125,1026.6539306640625],[1177.4814453125,987.666137669325]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"0e54f341e04a25fc7303ae41ca5d46ec","text":"● A thread shares resources with other threads of the same process: the code section, the data section, files and signals.","metadata":{"coordinates":{"points":[[300,1053.2741932248807],[300,1153.394287109375],[1501.2474365234375,1153.394287109375],[1501.2474365234375,1053.2741932248807]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"a3cab63ebd766783ee62fd3fd4059937","text":"Note : A new thread, or a child process of a given process, can be introduced by using the fork() system call. A process with n fork() system call generates 2^n – 1 child processes.","metadata":{"coordinates":{"points":[[295.3513488769531,1273.7032470703125],[295.3513488769531,1429.398681640625],[1493.0977783203125,1429.398681640625],[1493.0977783203125,1273.7032470703125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"2407db7f63816249ce1a1921059fd748","text":"There are two types of threads:","metadata":{"coordinates":{"points":[[297.3908386230469,1446.8187255859375],[297.3908386230469,1483.800048828125],[725.6559448242188,1483.800048828125],[725.6559448242188,1446.8187255859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"597836ed95cbf0d5264c87875d333823","text":"● User threads (User threads are implemented by users)","metadata":{"coordinates":{"points":[[350,1506.5497487804362],[350,1546.2469482421875],[1155.07080078125,1546.2469482421875],[1155.07080078125,1506.5497487804362]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"fdca300403e95d9caf0204b77a6cbf99","text":"● Kernel threads (Kernel threads are implemented by OS)","metadata":{"coordinates":{"points":[[350,1572.1584710026584],[350,1610.7965087890625],[1161.1793212890625,1610.7965087890625],[1161.1793212890625,1572.1584710026584]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"parent_id":"4aeb1b0c077f7d5a1969f62f9fb37f93","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"f3d0b10c99f0c65bba1c7afdbc2b1a22","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.73892211914062,2058.3984375],[197.73892211914062,2096.03759765625],[404.4027099609375,2096.03759765625],[404.4027099609375,2058.3984375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"6cc08d2d37fe22cb1b7f150a1a747251","text":"2","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.142578125],[1455.5664166666666,2094.250494708333],[1480.3212890625,2094.250494708333],[1480.3212890625,2059.142578125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":2,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"0ab7ff66e1f8e0da2a56a88c637988ba","text":"● Scheduling Algorithms :","metadata":{"coordinates":{"points":[[250,207.60533142089844],[250,257.9979553222656],[682.4285888671875,257.9979553222656],[682.4285888671875,207.60533142089844]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"b39bc8362758274d5310f9e2c19f9e9b","text":"1. First Come First Serve (FCFS) : Simplest scheduling algorithm that schedules according to arrival times of processes.","metadata":{"coordinates":{"points":[[300,291.8678894042969],[300,398.7231750488281],[1379.7508544921875,398.7231750488281],[1379.7508544921875,291.8678894042969]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"af6a1576746d435fd53ecaa99ebcc9e4","text":"2. Shortest Job First (SJF): Processes which have the shortest burst time are scheduled first.","metadata":{"coordinates":{"points":[[298.81268310546875,419.5567321777344],[298.81268310546875,525.5396728515625],[1479.4088134765625,525.5396728515625],[1479.4088134765625,419.5567321777344]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"ddcf32a14e013fa5c678b5fd5ff36146","text":"3. Shortest Remaining Time First (SRTF): It is a preemptive mode of SJF algorithm in which jobs are scheduled according to the shortest remaining time.","metadata":{"coordinates":{"points":[[300,544.6077270507812],[300,707.9006613749998],[1447.0177001953125,707.9006613749998],[1447.0177001953125,544.6077270507812]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"3a31fb497bdc1be416928d1575d18401","text":"4. Round Robin (RR) Scheduling: Each process is assigned a fixed time, in a cyclic way.","metadata":{"coordinates":{"points":[[298.2923583984375,731.8443603515625],[298.2923583984375,840.4122314453125],[1476.1718740000001,840.4122314453125],[1476.1718740000001,731.8443603515625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"4e074f38d60be53d834a7a8699d62700","text":"5. Priority Based scheduling (Non Preemptive): In this scheduling, processes are scheduled according to their priorities, i.e., highest priority process is scheduled first. If priorities of two processes match, then scheduling is according to the arrival time.","metadata":{"coordinates":{"points":[[296.8989562988281,858.8343505859375],[296.8989562988281,1083.21044921875],[1492.9850195,1083.21044921875],[1492.9850195,858.8343505859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"ba2d0edab2c9a4a2c51028e3eb17f79d","text":"6. Highest Response Ratio Next (HRRN): In this scheduling, processes with the highest response ratio are scheduled. This algorithm avoids starvation. Response Ratio = (Waiting Time + Burst time) / Burst time","metadata":{"coordinates":{"points":[[298.3439636230469,1104.687255859375],[298.3439636230469,1265.59619140625],[1474.9984130859375,1265.59619140625],[1474.9984130859375,1104.687255859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7e9c3dddb5c200bf47fe639616d835ee","text":"7. Multilevel Queue Scheduling (MLQ): According to the priority of the process, processes are placed in the different queues. Generally high priority processes are placed in the top level queue. Only after completion of processes from the top level queue, lower level queued processes are scheduled.","metadata":{"coordinates":{"points":[[299.889892578125,1286.0614013671875],[299.889892578125,1574.758544921875],[1488.2928466796875,1574.758544921875],[1488.2928466796875,1286.0614013671875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"65935a3a9818e566d0213c7acb3885c2","text":"8. Multilevel Feedback Queue (MLFQ) Scheduling: It allows the process to move in between queues. The idea is to separate processes according to the characteristics of their CPU bursts. If a process uses too much CPU time, it is moved to a lower-priority queue.","metadata":{"coordinates":{"points":[[299.03118896484375,1594.296875],[299.03118896484375,1822.3350830078125],[1501.681640625,1822.3350830078125],[1501.681640625,1594.296875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"parent_id":"0ab7ff66e1f8e0da2a56a88c637988ba","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"b9de8b4fcdf85d801fdaf7dbc0f7ca7f","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[196.8071746826172,2057.5146484375],[196.8071746826172,2096.843994140625],[405.43218994140625,2096.843994140625],[405.43218994140625,2057.5146484375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"55f140545020b27812c54ac4f5e5b59e","text":"3","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.212646484375],[1455.5664166666666,2094.250494708333],[1479.3057861328125,2094.250494708333],[1479.3057861328125,2059.212646484375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":3,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"8334cd8ef2b9875ab508f552c5b58f17","text":"● The Critical Section Problem:","metadata":{"coordinates":{"points":[[250,199.49220275878906],[250,236.9454803466797],[731.75634765625,236.9454803466797],[731.75634765625,199.49220275878906]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"c549f153d6339d4e88d74468eb198497","text":"1. Critical Section – The portion of the code in the program where shared variables are accessed and/or updated.","metadata":{"coordinates":{"points":[[295.1183166503906,260.34295654296875],[295.1183166503906,360.1347351074219],[1460.830810546875,360.1347351074219],[1460.830810546875,260.34295654296875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"624e1ec40f6215b5b063d3c4c78fb5a5","text":"2. Remainder Section – The remaining portion of the program excluding the Critical Section.","metadata":{"coordinates":{"points":[[291.17041015625,381.2773132324219],[291.17041015625,477.4759521484375],[1455.939208984375,477.4759521484375],[1455.939208984375,381.2773132324219]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"f73b9b8a3d4dee67604ca231fd947349","text":"3. Race around Condition – The final output of the code depends on the order in which the variables are accessed. This is termed as the race around condition.","metadata":{"coordinates":{"points":[[298.4490661621094,501.2059326171875],[298.4490661621094,604.376220703125],[1432.4757080078125,604.376220703125],[1432.4757080078125,501.2059326171875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e0a10c5d962764bf5b5fdb886358b0e6","text":"A solution for the critical section problem must satisfy the following three conditions:","metadata":{"coordinates":{"points":[[192.1746368408203,718.8455200195312],[192.1746368408203,757.8787841796875],[1329.2120361328125,757.8787841796875],[1329.2120361328125,718.8455200195312]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7c7d445325c576ffe1ab2cae3538fe83","text":"1. Mutual Exclusion – If a process Pi is executing in its critical section, then no other process is allowed to enter into the critical section.","metadata":{"coordinates":{"points":[[295.0853271484375,801.0272216796875],[295.0853271484375,899.5831909179688],[1478.1524658203125,899.5831909179688],[1478.1524658203125,801.0272216796875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"805669b85f333b00b4f7287435172861","text":"2. Progress – If no process is executing in the critical section, then the decision of a process to enter a critical section cannot be made by any other process that is executing in its remainder section. The selection of the process cannot be postponed indefinitely.","metadata":{"coordinates":{"points":[[300,923.1567487804361],[300,1134.06591796875],[1495.717424316772,1134.06591796875],[1495.717424316772,923.1567487804361]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"cff33d742eaddfda08146c2e93909c67","text":"3. Bounded Waiting – There exists a bound on the number of times other processes can enter into the critical section after a process has made a request to access the critical section and before the request is granted.","metadata":{"coordinates":{"points":[[300,1155.3093876693251],[300,1311.817626953125],[1472.60888671875,1311.817626953125],[1472.60888671875,1155.3093876693251]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"8334cd8ef2b9875ab508f552c5b58f17","filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"cc7893de4ac02768be193fa831ba9429","text":"● Synchronization Tools:","metadata":{"coordinates":{"points":[[250,1431.9471654471024],[250,1470.33935546875],[643.864990234375,1470.33935546875],[643.864990234375,1431.9471654471024]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"faeb24fd8b8a5ca17cf4fc65eee5a553","text":"1. Semaphore : Semaphore is a protected variable or abstract data type that is used to lock the resource being used. The value of the semaphore indicates the status of a common resource.","metadata":{"coordinates":{"points":[[346.6968688964844,1493.7158203125],[346.6968688964844,1646.0933837890625],[1478.977294921875,1646.0933837890625],[1478.977294921875,1493.7158203125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"cc7893de4ac02768be193fa831ba9429","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"df0e3c5b9e0fea52eb913b0c94ad9825","text":"There are two types of semaphores:","metadata":{"coordinates":{"points":[[400,1723.58056640625],[400,1763.2054443359375],[891.8244018554688,1763.2054443359375],[891.8244018554688,1723.58056640625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"cc7893de4ac02768be193fa831ba9429","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"350260a85e5ddb17c458b6bba9dbb849","text":"Binary semaphores (Binary semaphores take only 0 and 1 as value and are used to implement mutual exclusion and synchronize concurrent processes.) Counting semaphores (A counting semaphore is an integer variable whose value can range over an unrestricted domain.)","metadata":{"coordinates":{"points":[[393.9735412597656,1780.2554931640625],[393.9735412597656,2000.4384765625],[1498.2357177734375,2000.4384765625],[1498.2357177734375,1780.2554931640625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"parent_id":"cc7893de4ac02768be193fa831ba9429","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"712ab7a8908e1603eac2d4552dd0c0e6","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.2349395751953,2057.830078125],[197.2349395751953,2096.378662109375],[405.24639892578125,2096.378662109375],[405.24639892578125,2057.830078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"497450fe09ed7d8f48da5480272910dc","text":"4","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.34521484375],[1455.5664166666666,2094.250494708333],[1479.5501708984375,2094.250494708333],[1479.5501708984375,2059.34521484375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":4,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"4b6d204e0053f0035a92df05301a4b5e","text":"Mutex (A mutex provides mutual exclusion, either producer or consumer can have the key (mutex) and proceed with their work. As long as the buffer is filled by the producer, the consumer needs to wait, and vice versa. At any point of time, only one thread can work with the entire buffer. The concept can be generalized using semaphore.)","metadata":{"coordinates":{"points":[[396.7083435058594,199.58859252929688],[396.7083435058594,462.280029296875],[1486.8630930540496,462.280029296875],[1486.8630930540496,199.58859252929688]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"ac34da01dc8c640c1afa8dcd30587215","text":"● Deadlocks (Important):","metadata":{"coordinates":{"points":[[250,587.6116943359375],[250,635.2069709333651],[645.6146240234375,635.2069709333651],[645.6146240234375,587.6116943359375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"bc5ac739f31da60814c82359c71fe789","text":"A situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process. Deadlock can arise if following four conditions hold simultaneously (Necessary Conditions):","metadata":{"coordinates":{"points":[[300,668.5543823242188],[300,817.0755615234375],[1460.228515625,817.0755615234375],[1460.228515625,668.5543823242188]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"33cb036a14bc240310bcb118a7d5a2e6","text":"1. Mutual Exclusion – One or more than one resource is non-sharable (Only one process can use at a time).","metadata":{"coordinates":{"points":[[298.4969482421875,840.591776558214],[298.4969482421875,936.9661254882812],[1437.2744140625,936.9661254882812],[1437.2744140625,840.591776558214]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"23f30ef217bd79dd9b1a5699a76e235f","text":"2. Hold and Wait – A process is holding at least one resource and waiting for resources.","metadata":{"coordinates":{"points":[[300,961.7146654471028],[300,1057.5125732421875],[1369.5372314453125,1057.5125732421875],[1369.5372314453125,961.7146654471028]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"3fdadd09a67bc14ece0a852d30c8e392","text":"3. No Preemption – A resource cannot be taken from a process unless the process releases the resource.","metadata":{"coordinates":{"points":[[300,1082.836915447103],[300,1178.59228515625],[1448.021995833333,1178.59228515625],[1448.021995833333,1082.836915447103]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"75cbde1cdb8dc00afb61f3c4280409ab","text":"4. Circular Wait – A set of processes are waiting for each other in circular form.","metadata":{"coordinates":{"points":[[299.88153076171875,1203.9604987804364],[299.88153076171875,1242.81201171875],[1392.5450439453125,1242.81201171875],[1392.5450439453125,1203.9604987804364]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e5923ec5cccda562368144edd72d6867","text":"● Methods for handling deadlock: There are three ways to handle deadlock","metadata":{"coordinates":{"points":[[250,1369.401611328125],[250,1408.4234619140625],[1328.9239501953125,1408.4234619140625],[1328.9239501953125,1369.401611328125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"69aa2878d9c6e97195aff6a5910634db","text":"1. Deadlock prevention or avoidance : The idea is to not let the system into a deadlock state.","metadata":{"coordinates":{"points":[[300,1435.1765821137697],[300,1533.0831298828125],[1405.0111083984375,1533.0831298828125],[1405.0111083984375,1435.1765821137697]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"aeb1722b45c24f57178509aca8003465","text":"2. Deadlock detection and recovery : Let deadlock occur, then do preemption to handle it once occurred.","metadata":{"coordinates":{"points":[[289.1290588378906,1556.1383056640625],[289.1290588378906,1654.5732421875],[1440.9263916015625,1654.5732421875],[1440.9263916015625,1556.1383056640625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"fdef20d07f6840198ceabca5e974110b","text":"3. Ignore the problem all together : If deadlock is very rare, then let it happen and reboot the system. This is the approach that both Windows and UNIX take.","metadata":{"coordinates":{"points":[[286.15399169921875,1676.6025390625],[286.15399169921875,1777.7237548828125],[1465.4527587890625,1777.7237548828125],[1465.4527587890625,1676.6025390625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"parent_id":"ac34da01dc8c640c1afa8dcd30587215","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"4a94e26720224fef7a638d2d06294dc0","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[196.94309997558594,2057.7861328125],[196.94309997558594,2096.740478515625],[405.1283264160156,2096.740478515625],[405.1283264160156,2057.7861328125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"9bd52d6dc000e40bb74720d0364f1750","text":"5","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.50732421875],[1455.5664166666666,2094.250494708333],[1480.281494140625,2094.250494708333],[1480.281494140625,2059.50732421875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":5,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"9f6f78b581e9d80d5914ecee285ea359","text":"● Banker's algorithm is used to avoid deadlock. It is one of the deadlock-avoidance methods. It is named as Banker's algorithm on the banking system where a bank never allocates available cash in such a manner that it can no longer satisfy the requirements of all of its customers.","metadata":{"coordinates":{"points":[[250,200.46771240234375],[250,429.8429870605469],[1495.467529296875,429.8429870605469],[1495.467529296875,200.46771240234375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"1264eee479cf029cd6b2cfae295f25d6","text":"● Memory Management: These techniques allow the memory to be shared among multiple processes.","metadata":{"coordinates":{"points":[[250,554.4828491210938],[250,643.4909322374402],[1409.4794921875,643.4909322374402],[1409.4794921875,554.4828491210938]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"a35aa50769fb757a7c49e9273c211554","text":"● Overlays – The memory should contain only those instructions and data that are required at a given time.","metadata":{"coordinates":{"points":[[300,669.2830265582137],[300,767.0945434570312],[1457.929443359375,767.0945434570312],[1457.929443359375,669.2830265582137]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"624182281b4f8083f096adbedf40b9e8","text":"● Swapping – In multiprogramming, the instructions that have used the time slice are swapped out from the memory.","metadata":{"coordinates":{"points":[[300,790.3059692382812],[300,892.2361450195312],[1480.6334228515625,892.2361450195312],[1480.6334228515625,790.3059692382812]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"ListItem","element_id":"99b628dae53841ae9ba5f095a04412c2","text":"Techniques :","metadata":{"coordinates":{"points":[[250,911.5302210026585],[250,947.6413335026585],[484.3704434707166,947.6413335026585],[484.3704434707166,911.5302210026585]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"d9f97429e7e396eed72056a0bc8e3edf","text":"(a) Single Partition Allocation Schemes – The memory is divided into two parts. One part is kept to be used by the OS and the other is kept to be used by the users.","metadata":{"coordinates":{"points":[[295.9552917480469,971.8348999023438],[295.9552917480469,1065.801513671875],[1482.8660888671875,1065.801513671875],[1482.8660888671875,971.8348999023438]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"33e7a2fa8f2d12207140a9ad24f76cb5","text":"(b) Multiple Partition Schemes –","metadata":{"coordinates":{"points":[[299.5182800292969,1184.2694091796875],[299.5182800292969,1219.6920166015625],[766.7446899414062,1219.6920166015625],[766.7446899414062,1184.2694091796875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"1405a62a63eb8478acd4380dcd2d7bff","text":"1. Fixed Partition – The memory is divided into fixed size partitions.","metadata":{"coordinates":{"points":[[300,1343.6821932248806],[300,1380.4285888671875],[1237.5004888873832,1380.4285888671875],[1237.5004888873832,1343.6821932248806]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e9536fcc9e0a81d89b87a73a6447d1de","text":"2. Variable Partition – The memory is divided into variable sized partitions.","metadata":{"coordinates":{"points":[[297.34332275390625,1409.290915447103],[297.34332275390625,1446.4251708984375],[1334.2892551373832,1446.4251708984375],[1334.2892551373832,1409.290915447103]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7cc17b6a0411bd6ff873ef955615828e","text":"Note : Variable partition allocation schemes:","metadata":{"coordinates":{"points":[[296.7775573730469,1571.7083740234375],[296.7775573730469,1607.2020263671875],[901.16455078125,1607.2020263671875],[901.16455078125,1571.7083740234375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"63f1b92dcfbdd410bb16b31cff0b9e24","text":"1. First Fit – The arriving process is allotted the first hole of memory in which it fits completely.","metadata":{"coordinates":{"points":[[300,1652.635359891547],[300,1749.7032470703125],[1439.09912109375,1749.7032470703125],[1439.09912109375,1652.635359891547]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"9a79781f66d0d9fda233a77b042a58ed","text":"2. Best Fit – The arriving process is allotted the hole of memory in which it fits the best by leaving the minimum memory empty.","metadata":{"coordinates":{"points":[[283.0884704589844,1773.7589432248808],[283.0884704589844,1873.680419921875],[1507.940673828125,1873.680419921875],[1507.940673828125,1773.7589432248808]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"61453a74e9047e5d895d4985b63afb68","text":"3. Worst Fit – The arriving process is allotted the hole of memory in which it leaves the maximum gap.","metadata":{"coordinates":{"points":[[295.9794616699219,1894.8811932248807],[295.9794616699219,1994.5159912109375],[1489.8428111917724,1994.5159912109375],[1489.8428111917724,1894.8811932248807]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"parent_id":"33e7a2fa8f2d12207140a9ad24f76cb5","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"2ff91e9b006526cb59824ddcab23cd40","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.93492126464844,2058.403076171875],[197.93492126464844,2095.906005859375],[404.42388916015625,2095.906005859375],[404.42388916015625,2058.403076171875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"2b6d439571eb2ea835d8ad90d2cfb5ec","text":"6","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.675048828125],[1455.5664166666666,2094.250494708333],[1479.1868896484375,2094.250494708333],[1479.1868896484375,2059.675048828125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":6,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"ee5c2b9231adee0708cd4493d0e2d014","text":"Note:","metadata":{"coordinates":{"points":[[297.5212097167969,204.00918579101562],[297.5212097167969,241.52425016932503],[388.9703674316406,241.52425016932503],[388.9703674316406,204.00918579101562]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"dcbae9e4c2f9f9725e737cbafbe72e50","text":"● Best fit does not necessarily give the best results for memory allocation.","metadata":{"coordinates":{"points":[[300,293.2440848915471],[300,331.646484375],[1322.8314208984375,331.646484375],[1322.8314208984375,293.2440848915471]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"8be55c1cc50122bedad919380f5ab92b","text":"● The cause of external fragmentation is the condition in Fixed partitioning and Variable partitioning saying that the entire process should be allocated in a contiguous memory location.Therefore Paging is used.","metadata":{"coordinates":{"points":[[300,358.19818115234375],[300,514.2947387695312],[1383.6904047334388,514.2947387695312],[1383.6904047334388,358.19818115234375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"8904d07c051368dfb59fa91148009a1f","text":"1. Paging – The physical memory is divided into equal sized frames. The main memory is divided into fixed size pages. The size of a physical memory frame is equal to the size of a virtual memory frame.","metadata":{"coordinates":{"points":[[300,533.54736328125],[300,691.2092895507812],[1514.9969482421875,691.2092895507812],[1514.9969482421875,533.54736328125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e85063ab31932241bfa2c304f4f30459","text":"2. Segmentation – Segmentation is implemented to give users a view of memory. The logical address space is a collection of segments. Segmentation can be implemented with or without the use of paging.","metadata":{"coordinates":{"points":[[300,712.1283598915472],[300,872.376708984375],[1513.4063720703125,872.376708984375],[1513.4063720703125,712.1283598915472]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"ListItem","element_id":"17aee558052be5aaecb53fff2304edc5","text":"Page Fault:","metadata":{"coordinates":{"points":[[250,998.962403765218],[250,1029.517960015218],[464.5739665784776,1029.517960015218],[464.5739665784776,998.962403765218]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"463afcd5736f141c05057c3c925033a4","text":"A page fault is a type of interrupt, raised by the hardware when a running program accesses a memory page that is mapped into the virtual address space, but not loaded in physical memory.","metadata":{"coordinates":{"points":[[197.41580200195312,1072.501708984375],[197.41580200195312,1166.3336181640625],[1494.154296875,1166.3336181640625],[1494.154296875,1072.501708984375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"ee5c2b9231adee0708cd4493d0e2d014","filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"bb1291df3fec638b162f45be71ade7d7","text":"Page Replacement Algorithms (Important):","metadata":{"coordinates":{"points":[[194.54983520507812,1215.72412109375],[194.54983520507812,1264.97216796875],[880.8599243164062,1264.97216796875],[880.8599243164062,1215.72412109375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"dae60ce13d2422555ab4757f631004d1","text":"1. First In First Out (FIFO) –","metadata":{"coordinates":{"points":[[295.3745422363281,1324.0668321137694],[295.3745422363281,1360.466064453125],[711.3194051501056,1360.466064453125],[711.3194051501056,1324.0668321137694]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"374bb0a79e42cbffc335662fe5524775","text":"This is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced, the page in the front of the queue is selected for removal.","metadata":{"coordinates":{"points":[[348.5856628417969,1385.336181640625],[348.5856628417969,1587.1378173828125],[1470.2861328125,1587.1378173828125],[1470.2861328125,1385.336181640625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"dae60ce13d2422555ab4757f631004d1","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"597632267c2f17635df55e7597ab0d9f","text":"For example, consider page reference string 1, 3, 0, 3, 5, 6 and 3 page slots. Initially, all slots are empty, so when 1, 3, 0 come they are allocated to the empty slots —> 3 Page Faults. When 3 comes, it is already in memory so —> 0 Page Faults. Then 5 comes, it is not available in memory so it replaces the oldest page slot i.e 1. —> 1 Page Fault. Finally, 6 comes, it is also not available in memory so it replaces the oldest page slot i.e 3 —> 1 Page Fault.","metadata":{"coordinates":{"points":[[350,1608.1510009765625],[350,1920.32275390625],[1493.3988688873828,1920.32275390625],[1493.3988688873828,1608.1510009765625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"parent_id":"dae60ce13d2422555ab4757f631004d1","filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"d1d6a2f45941329ad4297444a9cea9b2","text":"Belady’s anomaly:","metadata":{"coordinates":{"points":[[348.40020751953125,1940.4486083984375],[348.40020751953125,1978.5816650390625],[620.6160278320312,1978.5816650390625],[620.6160278320312,1940.4486083984375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"854ab13d0e6b3da6824c823f93338ec9","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.6927032470703,2058.24267578125],[197.6927032470703,2095.9609375],[404.4554748535156,2095.9609375],[404.4554748535156,2058.24267578125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"3cf34b290c4606d9162470f0f48082f8","text":"7","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.25537109375],[1455.5664166666666,2094.250494708333],[1479.2830810546875,2094.250494708333],[1479.2830810546875,2059.25537109375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":7,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"bdbe5bc11a963c00dbf644f9f81a8ad5","text":"Belady’s anomaly proves that it is possible to have more page faults when increasing the number of page frames while using the First in First Out (FIFO) page replacement algorithm. For example, if we consider reference string ( 3 2 1 0","metadata":{"coordinates":{"points":[[350,196.96624755859375],[350,348.8033447265625],[1497.003173828125,348.8033447265625],[1497.003173828125,196.96624755859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"21fb114c7e5e510ae4955cedb42f5878","text":"Belady’s anomaly proves that it is possible to have more page faults when increasing the number of page frames while using the First in First Out (FIFO) page replacement algorithm. For example, if we consider reference string ( 3 2 1 0 3 2 4 3 2 1 0 4 ) and 3 slots, we get 9 total page faults, but if we increase slots to 4, we get 10 page faults.","metadata":{"coordinates":{"points":[[346.0198059082031,198.87100219726562],[346.0198059082031,457.8769226074219],[1507.40380859375,457.8769226074219],[1507.40380859375,198.87100219726562]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"8878eeb4b0799678a96bd977b51d3854","text":"3 2 4 3 2 1 0 4 ) and 3 slots, we get 9 total page faults, but if we increase slots to 4, we get 10 page faults.","metadata":{"coordinates":{"points":[[345.1427001953125,367.4637145996094],[345.1427001953125,461.0254821777344],[1454.896728515625,461.0254821777344],[1454.896728515625,367.4637145996094]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"9948331b9931b88f7dce7469c1e2bb8f","text":"2. Optimal Page replacement –","metadata":{"coordinates":{"points":[[299.9887390136719,482.98747100265837],[299.9887390136719,521.3641967773438],[762.5248413085938,521.3641967773438],[762.5248413085938,482.98747100265837]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"ff394d38b70b31e2ed164b7592897830","text":"In this algorithm, pages are replaced which are not used for the longest duration of time in the future.","metadata":{"coordinates":{"points":[[331.3742370605469,544.348876953125],[331.3742370605469,636.7113037109375],[1483.951416015625,636.7113037109375],[1483.951416015625,544.348876953125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"parent_id":"9948331b9931b88f7dce7469c1e2bb8f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"78d5cc7ed045dcfd47040757b5376d02","text":"Let us consider page reference string 7 0 1 2 0 3 0 4 2 3 0 3 2 and 4 page slots. Initially, all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults. 0 is already there so —> 0 Page fault. When 3 came it will take the place of 7 because it is not used for the longest duration of time in the future.—> 1 Page fault. 0 is already there so —> 0 Page fault. 4 will takes place of 1 —> 1 Page Fault. Now for the further page reference string —> 0 Page fault because they are already available in the memory.","metadata":{"coordinates":{"points":[[348.417724609375,710.973388671875],[348.417724609375,1080.492431640625],[1483.384765625,1080.492431640625],[1483.384765625,710.973388671875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"parent_id":"9948331b9931b88f7dce7469c1e2bb8f","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"b3b87b382a022ab8297165b02a751b75","text":"Optimal page replacement is perfect, but not possible in practice as an operating system cannot know future requests. The use of Optimal Page replacement is to set up a benchmark so that other replacement algorithms can be analyzed against it.","metadata":{"coordinates":{"points":[[350,1097.3258056640625],[350,1248.491455078125],[1498.7540283203125,1248.491455078125],[1498.7540283203125,1097.3258056640625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"parent_id":"9948331b9931b88f7dce7469c1e2bb8f","filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"7cc324794bf462c77f7814071a66ad7b","text":"3. Least Recently Used (LRU) –","metadata":{"coordinates":{"points":[[296.2672119140625,1270.09130859375],[296.2672119140625,1309.1058349609375],[772.4242553710938,1309.1058349609375],[772.4242553710938,1270.09130859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"27bcac0602f2b583cd4fd6ce11d1bef8","text":"In this algorithm, the page will be replaced with the one which is least recently used. Let say the page reference string 7 0 1 2 0 3 0 4 2 3 0 3 2 . Initially, we had 4-page slots empty. Initially, all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults. 0 is already there so —> 0 Page fault. When 3 comes it will take the place of 7 because it is least recently used —> 1 Page fault. 0 is already in memory so —> 0 Page fault. 4 will take place of 1 —> 1 Page Fault. Now for the further page reference string —> 0 Page fault because they are already available in the memory.","metadata":{"coordinates":{"points":[[350,1331.64892578125],[350,1756.3265380859375],[1488.2916259765625,1756.3265380859375],[1488.2916259765625,1331.64892578125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"parent_id":"7cc324794bf462c77f7814071a66ad7b","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"cbc6ba9dd97451342732122204d8ec6f","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.3805389404297,2058.134521484375],[197.3805389404297,2096.281982421875],[404.802001953125,2096.281982421875],[404.802001953125,2058.134521484375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"52430641bd3463044ba5a1a1cf66f1ae","text":"8","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.46826171875],[1455.5664166666666,2094.250494708333],[1479.0543212890625,2094.250494708333],[1479.0543212890625,2059.46826171875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":8,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"928fbd6eef8005831733f71e0293f04a","text":"● Disk Scheduling: Disk scheduling is done by operating systems to schedule I/O requests arriving for disk. Disk scheduling is also known as I/O scheduling.","metadata":{"coordinates":{"points":[[250,201.1197967529297],[250,294.1474609375],[1397.0599365234375,294.1474609375],[1397.0599365234375,201.1197967529297]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"6ec92a80bf3e1cc7626593e7ea49c9b7","text":"1. Seek Time: Seek time is the time taken to locate the disk arm to a specified track where the data is to be read or written.","metadata":{"coordinates":{"points":[[300,316.4428682248803],[300,411.9286193847656],[1447.484822083333,411.9286193847656],[1447.484822083333,316.4428682248803]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"b4fffac5dc2196f5cff82737931f46c3","text":"2. Rotational Latency: Rotational Latency is the time taken by the desired sector of disk to rotate into a position so that it can access the read/write heads.","metadata":{"coordinates":{"points":[[300,437.56645711376933],[300,534.9359130859375],[1451.4015474290497,534.9359130859375],[1451.4015474290497,437.56645711376933]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"26cde6211a0253d6ec521396473b1074","text":"3. Transfer Time: Transfer time is the time to transfer the data. It depends on the rotating speed of the disk and number of bytes to be transferred.","metadata":{"coordinates":{"points":[[300,558.6886932248806],[300,656.0914306640625],[1429.9444580078125,656.0914306640625],[1429.9444580078125,558.6886932248806]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"5ee178346b1376262739769e5f49bd9a","text":"4. Disk Access Time: Seek Time + Rotational Latency + Transfer Time","metadata":{"coordinates":{"points":[[298.777099609375,679.6848754882812],[298.777099609375,717.6531372070312],[1288.522216796875,717.6531372070312],[1288.522216796875,679.6848754882812]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"153e12322dd4d219c436b31b57626426","text":"5. Disk Response Time: Response Time is the average of time spent by a request waiting to perform its I/O operation. Average Response time is the response time of all requests.","metadata":{"coordinates":{"points":[[300,745.0443725585938],[300,898.239501953125],[1477.0858154296875,898.239501953125],[1477.0858154296875,745.0443725585938]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"eafd23a06fcfa9e0826797a1d0a9c6d3","text":"● Disk Scheduling Algorithms (Important):","metadata":{"coordinates":{"points":[[250,1103.7198486328125],[250,1153.5220947265625],[946.9351806640625,1153.5220947265625],[946.9351806640625,1103.7198486328125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e07cda1957d58df5bf074e8a73c5597a","text":"1. FCFS: FCFS is the simplest of all the Disk Scheduling Algorithms. In FCFS, the requests are addressed in the order they arrive in the disk queue.","metadata":{"coordinates":{"points":[[300,1190.1190185546875],[300,1287.9482421875],[1433.0919189453125,1287.9482421875],[1433.0919189453125,1190.1190185546875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"parent_id":"eafd23a06fcfa9e0826797a1d0a9c6d3","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"c13ee81e8d8732302eed119e5314613a","text":"2. SSTF: In SSTF (Shortest Seek Time First), requests having the shortest seek time are executed first. So, the seek time of every request is calculated in advance in a queue and then they are scheduled according to their calculated seek time. As a result, the request near the disk arm will get executed first.","metadata":{"coordinates":{"points":[[300,1311.9778043359918],[300,1520.8486328125],[1462.0369432751054,1520.8486328125],[1462.0369432751054,1311.9778043359918]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"parent_id":"eafd23a06fcfa9e0826797a1d0a9c6d3","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"0aff4e499e6a10ebcd172980bc6271d5","text":"3. SCAN: In SCAN algorithm the disk arm moves into a particular direction and services the requests coming in its path and after reaching the end of the disk, it reverses its direction and again services the request arriving in its path. So, this algorithm works like an elevator and hence is also known as elevator algorithm.","metadata":{"coordinates":{"points":[[300,1544.131137669325],[300,1752.4412841796875],[1449.5067138671875,1752.4412841796875],[1449.5067138671875,1544.131137669325]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"parent_id":"eafd23a06fcfa9e0826797a1d0a9c6d3","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"5d9bea805903d64ab16ec5233f209088","text":"4. CSCAN: In SCAN algorithm, the disk arm again scans the path that has been scanned, after reversing its direction. So, it may be possible that too many requests are waiting at the other end or there may be zero or few requests pending at the scanned area.","metadata":{"coordinates":{"points":[[300,1776.2830821137698],[300,1982.9371337890625],[1475.2459891666663,1982.9371337890625],[1475.2459891666663,1776.2830821137698]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"parent_id":"eafd23a06fcfa9e0826797a1d0a9c6d3","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"1eb48546b583a5fbfe346f9f7080526d","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.65902709960938,2058.541748046875],[197.65902709960938,2095.974609375],[404.4053955078125,2095.974609375],[404.4053955078125,2058.541748046875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"PageNumber","element_id":"a56db678be8297c13466fd3c93ebdced","text":"9","metadata":{"coordinates":{"points":[[1455.5664166666666,2059.764404296875],[1455.5664166666666,2094.250494708333],[1479.300537109375,2094.250494708333],[1479.300537109375,2059.764404296875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":9,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"0e139e7ef241df1434744f11ebb02a52","text":"5. LOOK: It is similar to the SCAN disk scheduling algorithm except for the difference that the disk arm in spite of going to the end of the disk goes only to the last request to be serviced in front of the head and then reverses its direction from there only. Thus it prevents the extra delay which occurred due to unnecessary traversal to the end of the disk.","metadata":{"coordinates":{"points":[[300,202.70086669921875],[300,470.451171875],[1499.265869140625,470.451171875],[1499.265869140625,202.70086669921875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":10,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"9ebf7403447720c425aa0251685052a0","text":"6. CLOOK: As LOOK is similar to SCAN algorithm, CLOOK is similar to CSCAN disk scheduling algorithm. In CLOOK, the disk arm in spite of going to the end goes only to the last request to be serviced in front of the head and then from there goes to the other end’s last request. Thus, it also prevents the extra delay which occurred due to unnecessary traversal to the end of the disk.","metadata":{"coordinates":{"points":[[300,489.9807434082031],[300,759.26611328125],[1496.6605224609375,759.26611328125],[1496.6605224609375,489.9807434082031]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":10,"filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"c00f52fb1a5cb4e8b7ceff38e08d3001","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.80197143554688,2058.537353515625],[197.80197143554688,2096.014892578125],[404.451171875,2096.014892578125],[404.451171875,2058.537353515625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":10,"filename":"Operating System Notes.pdf"}},{"type":"UncategorizedText","element_id":"722ee3dc4b69512f776503ad6c6ce9b4","text":"10","metadata":{"coordinates":{"points":[[1455.5664166666666,2060.917161375],[1455.5664166666666,2094.250494708333],[1492.6432393333334,2094.250494708333],[1492.6432393333334,2060.917161375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":10,"filename":"Operating System Notes.pdf"}},{"type":"Title","element_id":"53125cc098bd7ede3b67c41a8f23964e","text":"Key Terms","metadata":{"coordinates":{"points":[[759.2330322265625,210.71498107910156],[759.2330322265625,265.86666567916666],[955.3211669921875,265.86666567916666],[955.3211669921875,210.71498107910156]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"103098685e8d3699e185d3848dce6e43","text":"● Real-time system is used in the case when rigid-time requirements have been placed on the operation of a processor. It contains well defined and fixed time constraints.","metadata":{"coordinates":{"points":[[250,405.3833923339844],[250,563.5226891527777],[1511.1964111328125,563.5226891527777],[1511.1964111328125,405.3833923339844]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7bdf9814fd770bc02f4aa9b0d07cc37c","text":"● A monolithic kernel is a kernel which includes all operating system code in a single executable image.","metadata":{"coordinates":{"points":[[250,586.45458984375],[250,688.854736328125],[1458.594970703125,688.854736328125],[1458.594970703125,586.45458984375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"fee1b2c42e9c89d93520eb15ed390799","text":"● Micro kernel: Microkernel is the kernel which runs minimal performance affecting services for the operating system. In the microkernel operating system all other operations are performed by the processor.","metadata":{"coordinates":{"points":[[250,709.3709716796875],[250,871.3156127929688],[1506.01025390625,871.3156127929688],[1506.01025390625,709.3709716796875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"58bf329bd08eee3f8f7f3bc360848d9d","text":"Macro Kernel: Macro Kernel is a combination of micro and monolithic kernel.","metadata":{"coordinates":{"points":[[300,922.4180908203125],[300,963.5177001953125],[1454.6466064453125,963.5177001953125],[1454.6466064453125,922.4180908203125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"4a2cc52785b6618b64eb8428a8439249","text":"● Re-entrancy : It is a very useful memory saving technique that is used for multi-programmed time sharing systems. It provides functionality that multiple users can share a single copy of a program during the same period. It has two key aspects:The program code cannot modify itself and the local data for each user process must be stored separately.","metadata":{"coordinates":{"points":[[250,1018.6238403320312],[250,1300.603515625],[1459.5413818359375,1300.603515625],[1459.5413818359375,1018.6238403320312]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"2f192c23d688455aec24117592647330","text":"● Demand paging specifies that if an area of memory is not currently being used, it is swapped to disk to make room for an application's need.","metadata":{"coordinates":{"points":[[250,1318.925048828125],[250,1421.4122314453125],[1487.967041015625,1421.4122314453125],[1487.967041015625,1318.925048828125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"0d058ab137b44401d6f1d2dd9f81bccd","text":"● Virtual memory (Imp) is a very useful memory management technique which enables processes to execute outside of memory. This technique is especially used when an executing program cannot fit in the physical memory.","metadata":{"coordinates":{"points":[[250,1440.8809814453125],[250,1602.0234375],[1461.399169921875,1602.0234375],[1461.399169921875,1440.8809814453125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"c462c5938477183c6ef4d496b3aa932b","text":"● RAID stands for Redundant Array of Independent Disks. It is used to store the same data redundantly to improve the overall performance. There are 7 RAID levels.","metadata":{"coordinates":{"points":[[250,1622.0963134765625],[250,1780.856661375],[1455.95751953125,1780.856661375],[1455.95751953125,1622.0963134765625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"a4367eb9fefdd57643d2cf82e3db3749","text":"● Logical address space specifies the address that is generated by the CPU. On the other hand, physical address space specifies the address that is seen by the memory unit.","metadata":{"coordinates":{"points":[[250,1804.012939453125],[250,1968.82666015625],[1487.1925048828125,1968.82666015625],[1487.1925048828125,1804.012939453125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"parent_id":"53125cc098bd7ede3b67c41a8f23964e","filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"42223a050b90ff3b45476f0fbe95abea","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.65187072753906,2058.29248046875],[197.65187072753906,2096.03369140625],[404.3734130859375,2096.03369140625],[404.3734130859375,2058.29248046875]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"filename":"Operating System Notes.pdf"}},{"type":"UncategorizedText","element_id":"c9eb780b45a1cd5a16afb28ca9c19123","text":"11","metadata":{"coordinates":{"points":[[1455.5664166666666,2060.9158002638887],[1455.5664166666666,2094.249133597222],[1490.80404675,2094.249133597222],[1490.80404675,2060.9158002638887]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":11,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"3e5560a1a93c488dc082de90aa24ef3a","text":"● Fragmentation is a phenomenon of memory wastage. It reduces the capacity and performance because space is used inefficiently.","metadata":{"coordinates":{"points":[[250,199.31033325195312],[250,301.9736022949219],[1448.6490843333336,301.9736022949219],[1448.6490843333336,199.31033325195312]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"173949e0fe679ac3bc08819534e2ca01","text":"1. Internal fragmentation: It occurs when we deal with the systems that have fixed size allocation units.","metadata":{"coordinates":{"points":[[348.1726989746094,328.4939880371094],[348.1726989746094,431.2755432128906],[1445.845947265625,431.2755432128906],[1445.845947265625,328.4939880371094]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"d0b42752c4817a5d58d9c4267a58e3af","text":"2. External fragmentation: It occurs when we deal with systems that have variable-size allocation units.","metadata":{"coordinates":{"points":[[349.0246887207031,462.1063537597656],[349.0246887207031,564.56103515625],[1475.3995361328125,564.56103515625],[1475.3995361328125,462.1063537597656]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"aec42dadc6cedef29d3062cc493ad6b0","text":"● Spooling is a process in which data is temporarily gathered to be used and executed by a device, program or the system. It is associated with printing. When different applications send output to the printer at the same time, spooling keeps these all jobs into a disk file and queues them accordingly to the printer.","metadata":{"coordinates":{"points":[[250,599.80859375],[250,818.3861083984375],[1502.3974609375,818.3861083984375],[1502.3974609375,599.80859375]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"831ae0d07d6e2a192c4b930e44c6adcf","text":"● Starvation is Resource management problem. In this problem, a waiting process does not get the resources it needs for a long time because the resources are being allocated to other processes.","metadata":{"coordinates":{"points":[[250,850.2110595703125],[250,1011.3578491210938],[1513.6787109375,1011.3578491210938],[1513.6787109375,850.2110595703125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"7ad3186919a8496393f10d8ba25f9204","text":"● Aging is a technique used to avoid starvation in the resource scheduling system.","metadata":{"coordinates":{"points":[[250,1041.7662353515625],[250,1083.0560302734375],[1493.2301025390625,1083.0560302734375],[1493.2301025390625,1041.7662353515625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"786016183f0bb5c5994209d64a72c033","text":"● Advantages of multithreaded programming:","metadata":{"coordinates":{"points":[[250,1115.005126953125],[250,1157.2542724609375],[994.398193359375,1157.2542724609375],[994.398193359375,1115.005126953125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"f0672092d3e8f6a4ec7a4e613a97847a","text":"1. Enhance the responsiveness to the users.","metadata":{"coordinates":{"points":[[343.1286926269531,1187.7843017578125],[343.1286926269531,1227.3671875],[1035.1287841796875,1227.3671875],[1035.1287841796875,1187.7843017578125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"8ab6f7ff8b85e182b3823865e306da2f","text":"2. Resource sharing within the process.","metadata":{"coordinates":{"points":[[346.05810546875,1263.043212890625],[346.05810546875,1303.7032470703125],[949.6686401367188,1303.7032470703125],[949.6686401367188,1263.043212890625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"ec7a19955165e38932b24aa55e024138","text":"3. Economical","metadata":{"coordinates":{"points":[[348.4732971191406,1339.142822265625],[348.4732971191406,1376.0226703055555],[576.944091796875,1376.0226703055555],[576.944091796875,1339.142822265625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"e84ec6f665b5420fa8fc9af33ab99756","text":"4. Completely utilize the multiprocessing architecture.","metadata":{"coordinates":{"points":[[350,1412.725830078125],[350,1452.8485107421875],[1155.134033203125,1452.8485107421875],[1155.134033203125,1412.725830078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"NarrativeText","element_id":"d30c3bf5e4ce06f593a2e3d0004f09e5","text":"● Thrashing is a phenomenon in virtual memory schemes when the processor spends most of its time in swapping pages, rather than executing instructions.","metadata":{"coordinates":{"points":[[250,1486.1788330078125],[250,1591.1741943359375],[1462.204345703125,1591.1741943359375],[1462.204345703125,1486.1788330078125]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"Footer","element_id":"7a0f9c6ada5b13461fed94f8d90596b1","text":"Apni Kaksha","metadata":{"coordinates":{"points":[[197.2460174560547,2057.906494140625],[197.2460174560547,2096.471435546875],[405.0601806640625,2096.471435546875],[405.0601806640625,2057.906494140625]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}},{"type":"UncategorizedText","element_id":"ba6adf4f41366ec25beac238895a4b03","text":"12","metadata":{"coordinates":{"points":[[1455.5664166666666,2060.9158002638887],[1455.5664166666666,2094.249133597222],[1492.6432393333334,2094.249133597222],[1492.6432393333334,2060.9158002638887]],"system":"PixelSpace","layout_width":1700,"layout_height":2200},"filetype":"application/pdf","languages":["eng"],"page_number":12,"filename":"Operating System Notes.pdf"}}]